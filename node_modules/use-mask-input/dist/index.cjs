'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var Inputmask = require('inputmask');

function flow(...funcs) {
    const { length  } = funcs;
    let index = length;
    while(index--){
        if (typeof funcs[index] !== 'function') {
            throw new TypeError('Expected a function');
        }
    }
    return (...args)=>{
        let i = 0;
        let result = length ? funcs[i].apply(this, args) : args[0];
        while(++i < length){
            result = funcs[i].call(this, result);
        }
        return result;
    };
}

const isServer = !(typeof window !== 'undefined' && window.document && window.document.createElement);

function _define_property$2(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread$2(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property$2(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys$2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props$2(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys$2(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
const getMaskOptions = (mask, _options)=>{
    const options = _object_spread_props$2(_object_spread$2({}, _options), {
        jitMasking: false
    });
    if (!mask) return options;
    const masks = {
        datetime: _object_spread$2({
            alias: 'datetime',
            inputFormat: 'dd/mm/yyyy',
            placeholder: 'dd/mm/yyyy'
        }, options),
        cpf: _object_spread$2({
            mask: '999.999.999-99',
            placeholder: '___.___.___-__'
        }, options),
        cnpj: _object_spread$2({
            mask: '99.999.999/9999-99',
            placeholder: '__.___.___/____-__'
        }, options),
        email: _object_spread$2({
            alias: 'email',
            placeholder: ''
        }, options),
        numeric: _object_spread$2({
            alias: 'numeric',
            placeholder: ''
        }, options),
        currency: _object_spread$2({
            alias: 'currency',
            prefix: '$ ',
            placeholder: ''
        }, options),
        decimal: _object_spread$2({
            alias: 'decimal',
            placeholder: ''
        }, options),
        integer: _object_spread$2({
            alias: 'integer',
            placeholder: ''
        }, options),
        percentage: _object_spread$2({
            alias: 'percentage',
            placeholder: ' %',
            suffix: ' %'
        }, options),
        url: _object_spread$2({
            alias: 'url',
            placeholder: 'https://'
        }, options),
        ip: _object_spread$2({
            alias: 'ip'
        }, options),
        mac: _object_spread$2({
            alias: 'mac'
        }, options),
        ssn: _object_spread$2({
            alias: 'ssn'
        }, options)
    };
    if (typeof mask === 'string') {
        if (masks[mask]) return masks[mask];
    } else if (typeof mask === 'object') {
        return _object_spread$2({}, mask, options);
    }
    return _object_spread$2({
        mask
    }, options);
};

const useInputMask = (props)=>{
    const { mask , register , options  } = props;
    const ref = react.useRef(null);
    if (isServer) return ref;
    react.useEffect(()=>{
        if (!isServer) {
            if (!ref.current) return;
            const maskInput = Inputmask(getMaskOptions(mask, options));
            maskInput.mask(ref.current);
            if (register && ref.current) {
                register(ref.current);
            }
        }
    }, [
        mask,
        register,
        options
    ]);
    return ref;
};

function _define_property$1(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread$1(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property$1(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props$1(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys$1(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
const withHookFormMask = (register, mask, options)=>{
    //
    let newRef;
    if (register) {
        const { ref  } = register;
        const maskInput = Inputmask(getMaskOptions(mask, options));
        newRef = flow((_ref)=>{
            if (_ref) maskInput.mask(_ref);
            return _ref;
        }, ref);
    }
    return _object_spread_props$1(_object_spread$1({}, register), {
        ref: newRef
    });
};

const withMask = (mask, options)=>(input)=>{
        //
        if (isServer) return input;
        if (mask === null) return input;
        const maskInput = Inputmask(getMaskOptions(mask, options));
        if (input) {
            maskInput.mask(input);
        }
        return input;
    };

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function useHookFormMask(registerFn) {
    return (fieldName, mask, options)=>{
        if (!registerFn) throw new Error('registerFn is required');
        const _registerFn = registerFn(fieldName), { ref  } = _registerFn, restRegister = _object_without_properties(_registerFn, [
            "ref"
        ]);
        const maskInput = Inputmask(getMaskOptions(mask, options));
        const newRef = flow((_ref)=>{
            if (_ref) maskInput.mask(_ref);
            return _ref;
        }, ref);
        return _object_spread_props(_object_spread({}, restRegister), {
            ref: newRef
        });
    };
}

exports.default = useInputMask;
exports.useHookFormMask = useHookFormMask;
exports.withHookFormMask = withHookFormMask;
exports.withMask = withMask;
//# sourceMappingURL=index.cjs.map
